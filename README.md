
##java原生锁synchronized介绍
synchronized用的锁是存在java对象头中，上锁，改变的就是对象头。

synchronized锁有5种状态：无锁，偏向锁，轻量级锁，重量级锁，GC标志信息。

偏向锁、轻量级锁、重量级锁适用于不同的并发场景：
- 偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。
- 轻量级锁：多个线程交替使用锁；允许短时间的锁竞争。
- 重量级锁：有实际竞争，且锁竞争时间长。

如果锁竞争程度逐渐提高，那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。


### 无锁

对象没被synchronized()锁住，此时是无锁状态。

此时对象头中的mark word(64位)存储数据如下：

25位无意义 | 31位存的是hashCode | 1位无意义 | 4位存的是对象的年龄(在年轻代每回收一次还存活则加1) | 1位存的是偏向锁状态(此时值是0) | 2位存的是锁状态(此时值是01)

### 偏向锁(用户态下即可执行)

在java应用启动后的4秒内new出来的对象，且该对象没被synchronized()锁住，此时因为开启了偏向锁，所以是偏向锁状态。
若该对象被synchronized()锁住，且大多数时间只有一个线程会使用这个锁，则会使用偏向锁，第一个获取锁的线程id会被存到mark word里面。

此时对象头中的mark word(64位)存储数据如下：

54位存获取了锁的线程id | 2位Epoch | 1位无意义 | 4位存的是对象的年龄(在年轻代每回收一次还存活则加1) | 1位存的是偏向锁状态(此时值是1) | 2位存的是锁状态(此时值是01)

### 轻量级锁，也叫自旋锁(用户态下即可执行)
当有两个线程竞争这把锁，首先撤销偏向锁升级为轻量级锁，然后两个线程的线程栈里面都创建一个lock record的记录，
最后两个线程竞争把lock record的指针存到mark word里面，谁先存成功谁获得锁，
另一个线程就不断地查看锁什么时候释放掉，再去加锁，所以叫自旋。
或者是在java应用启动后的4秒内，如果对对象加锁，由于关闭了偏向锁，所以直接使用了轻量级锁。

此时对象头中的mark word(64位)存储数据如下：

62位存的是线程栈里面lock record的指针 | 2位存的是锁状态(此时值是00)

### 重量级锁(需要切换到内核态执行，切换过程很耗时间资源)
当竞争加剧：有线程超过10次自旋或自旋线程数超过cpu核数一半(jdk1.6后jvm自己内部控制)，升级为重量级锁，
切换成内核态，向系统申请调度资源，新建一个对象objectmonitor(由c++实现的)，将竞争的线程都挂起并放到
objectmonitor中的一个队列中，然后由系统调度加锁解锁。

此时对象头中的mark word(64位)存储数据如下：

62位存的是objectmonitor的地址 | 2位存的是锁状态(此时值是10)

### GC标志信息
当该对象没有其他引用的地方，被GC标志为可回收对象时，是GC标志状态

此时对象头中的mark word(64位)存储数据如下：

62位存的是GC需要的相关信息 | 2位存的是锁状态(此时值是11)

### java应用启动

java应用启动的时候会有多个系统自带的线程执行synchronized代码块，必然会导致由偏向锁升级为轻量级锁，为了避免升级所带来额外的开销，
  此时jvm会关闭偏向锁，直接使用轻量级锁，默认等待4秒后再开启偏向锁，可用-XX:BiasedLockingStartupDelay参数设置时间。


### 可重入
synchronized是可重入锁：
偏向锁和轻量级锁在重入的时候，对应线程栈的lock record个数加1，解开一个锁就pop一个lock record出去。
重量级锁是将重入的次数记录在objectmonitor的一个字段上。

### 用户态和内核态
进程在运行时一般都是用户态，此时权限是最低的。
但一旦要执行系统硬件层的操作，比如读写文件，网络传输等需要切换到内核态才能执行，但这个切换过程是很耗时的。

## ReentrantLock简介
### 背景
Reentrantlock 是在java 1.5 并发包增加的一个可重入的锁，是基于AQS（AbstractQueuedSynchronized）实现的，它有公平锁和不公平锁两种实现方式。
所谓ReentrantLock的再入特性，是指当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，
这是对锁获取粒度的一个概念，也就是锁的持有是以线程为单位而不是基于调用次数.Java 锁实现强调再入性是为了和 pthread 的行为进行区分。
ReentrantLock的语义和synchronized基本相同，与synchronized相比，ReentrantLock使用上更加灵活。

- 可通过Condition类实现多路通知功能

- 提供多个便利的方法，如判断是否有线程在排队等待锁

- 可设置所为公平锁或非公平锁

- 可以响应中断请求

- 带超时的获取锁尝试



### volatile修饰符

 在本次线程内，当读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后再取变量值时，就直接从寄存器中取值；
 当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以便保持一致
 当变量在因别的线程等而改变了值，该寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致
 当该寄存器在因别的线程等而改变了值，原变量的值不会改变，从而造成应用程序读取的值和实际的变量值不一致
 
![](https://upload-images.jianshu.io/upload_images/5954965-a866fcf5501b54c1)

上图可以看到一个8核CPU计算机系统，每个CPU有cache（CPU内部的高速缓存，寄存器），管芯内还带有一个互联模块，使管芯内的两个核可以互相通信。在图中央的系统互联模块可以让四个管芯相互通信，并且将管芯与主存连接起来。数据以“缓存线”为单位在系统中传输，“缓存线”对应于内存中一个 2 的幂大小的字节块，大小通常为 32 到 256 字节之间。当 CPU 从内存中读取一个变量到它的寄存器中时，必须首先将包含了该变量的缓存线读取到 CPU 高速缓存。同样地，CPU 将寄存器中的一个值存储到内存时，不仅必须将包含了该值的缓存线读到 CPU 高速缓存，还必须确保没有其他 CPU 拥有该缓存线的拷贝。

### Unsafe类

不安全的类,提供了类似C++手动管理内存的能力可以操作jvm管理之外的内存
可以提供CAS操作（比较并交换）是CPU指令级的操作

Unsafe中一共有82个public native修饰的方法，还有几十个基于这82个public native方法的其他方法。这些方法大体可以归结为以下几类：
1. 初始化操作
2. 操作对象属性
3. 操作数组元素
4. 线程挂起和回复
5. CAS机制
